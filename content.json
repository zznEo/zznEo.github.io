{"meta":{"title":"Never Give Up!","subtitle":null,"description":null,"author":"nEo.大魔王","url":"http://yoursite.com","root":"/"},"pages":[{"title":"ABOUT","date":"2019-07-11T13:05:04.000Z","updated":"2019-07-14T13:52:27.912Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Me 蒟蒻ACMer&nbsp;|&nbsp;C++&nbsp;|&nbsp;数据结构&nbsp;|&nbsp;算法 Timeline 2018.10.27 &nbsp;&nbsp;&nbsp; 加入软院ACM集训队 2019.01.05 &nbsp;&nbsp;&nbsp; 郑州轻工业大学–“卓见杯” 河南省高校邀请赛 金奖 2019.02.28 &nbsp;&nbsp;&nbsp; Fall in love with her 2019.07.14 &nbsp;&nbsp;&nbsp; 迁移 Blog 至公网服务器 To Honorary Man这个网站的搭设离不开我的好学长，ACM的好队员，人民群众的好榜样: &nbsp; zzzhy他确实是一名德艺双馨的人民老艺术家，在这段时间给了我很多帮助。没有&nbsp;zzzhy，就不会有这个网站。感谢他。阿门。"},{"title":"分类","date":"2019-07-14T08:02:25.000Z","updated":"2019-07-14T11:54:01.166Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-14T08:02:32.000Z","updated":"2019-07-14T11:54:21.401Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Luogu1338 末日传说","slug":"LuoguP1338","date":"2019-07-14T09:41:40.000Z","updated":"2019-07-14T11:56:11.601Z","comments":true,"path":"2019/07/14/LuoguP1338/","link":"","permalink":"http://yoursite.com/2019/07/14/LuoguP1338/","excerpt":"描述只要是参加jsoi活动的同学一定都听说过Hanoi塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。 在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从1开始的连续整数，1表示最小而N表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。 我们用1-N来表示日历的元素，第一天日历就是 1, 2, 3, … N 第二天，日历自动变为 1, 2, 3, … N, N-1 ……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。 日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃……他还预言到，假如某一个日期的逆序达到一个值M的时候，世界末日就要降临。 什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到M后，末日就要降临，人们都期待一个贤者，能够预见那一天，到底将在什么时候到来？","text":"描述只要是参加jsoi活动的同学一定都听说过Hanoi塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。 在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从1开始的连续整数，1表示最小而N表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。 我们用1-N来表示日历的元素，第一天日历就是 1, 2, 3, … N 第二天，日历自动变为 1, 2, 3, … N, N-1 ……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。 日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃……他还预言到，假如某一个日期的逆序达到一个值M的时候，世界末日就要降临。 什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到M后，末日就要降临，人们都期待一个贤者，能够预见那一天，到底将在什么时候到来？ 输入输出格式输入格式只包含一行两个正整数，分别为N和M。 输出格式输出一行，为世界末日的日期，每个数字之间用一个空格隔开。 输入输出样例输入样例1：5 4输出样例1：1 3 5 4 2说明对于10%的数据有N &lt;= 10。 对于40%的数据有N &lt;= 1000。 对于100%的数据有 N &lt;= 50000。 所有数据均有解。 题解题目意思看了半天没看懂搜了题解看到的题意。意思是给你一个N，让你在1-N的序列中找到一个序列使得这个序列的逆序对的个数满足M,并且该序列的字典序最小。 对于一个序列，它的最大逆序对的个数给n*(n-1)/2，即该序列严格降序。所以当我们按位来考虑这个序列的逆序数时，我们去判断这一位对该序列逆序对的贡献是否比M大。例如N = 5，M = 4.我们在考虑1的时候可以计算得出，剩下的4位数可以产生的最大逆序对的个数是比M大的，所以这个1可有可无，我们就可以把他放到序列的最前端。而到了2时我们发现，去掉了这个2是无法满足逆序对大于M的要求，此时按照贪心我们把2放到最后，这样可以使2这个数产生的逆序对最多，也就使M减小的最多，进而影响后面我们可以找到跟多的无关元素。这样就好写了。对于每个数都有两种方式 去掉当前数，剩下的数仍可构成比M多个逆序对把当前数放到后方，让M-（当前数提供的逆序对的个数）这样直接O(n)的时间复杂度就过去了(要开long long)。 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;typedef long long ll;const int MAXN = 1e5+7;const int INF = 0x7fffffff;using namespace std;ll a[MAXN]; int main() &#123; ll n,m; cin &gt;&gt; n &gt;&gt; m; ll ans[MAXN],l = 1,r = n; for(ll i = 1; i &lt;= n; i++) &#123; ll t = (n-i)*(n-i-1)/2; if(t &gt;= m) &#123; ans[l] = i; l++; &#125; else &#123; ans[r] = i; r--; m -= (r - l + 1); &#125; &#125; for(ll i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; return 0;&#125;","categories":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/categories/思维/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"}]},{"title":"琪露诺","slug":"Luogu1725","date":"2019-07-11T14:11:24.800Z","updated":"2019-07-14T11:55:39.461Z","comments":true,"path":"2019/07/11/Luogu1725/","link":"","permalink":"http://yoursite.com/2019/07/11/Luogu1725/","excerpt":"描述在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。 某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。 小河可以看作一列格子依次编号为0到N，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子i时，她只移动到区间[i+l,i+r]中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。 每一个格子都有一个冰冻指数A[i]，编号为0的格子冰冻指数为0。当琪露诺停留在那一格时就可以得到那一格的冰冻指数A[i]。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。 但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。 开始时，琪露诺在编号0的格子上，只要她下一步的位置编号大于N就算到达对岸。","text":"描述在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。 某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。 小河可以看作一列格子依次编号为0到N，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子i时，她只移动到区间[i+l,i+r]中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。 每一个格子都有一个冰冻指数A[i]，编号为0的格子冰冻指数为0。当琪露诺停留在那一格时就可以得到那一格的冰冻指数A[i]。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。 但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。 开始时，琪露诺在编号0的格子上，只要她下一步的位置编号大于N就算到达对岸。 输入输出格式输入格式：第1行：3个正整数N, L, R 第2行：N+1个整数，第i个数表示编号为i-1的格子的冰冻指数A[i-1] 输出格式：一个整数，表示最大冰冻指数。保证不超过2^31-1 输入输出样例输入样例1：5 2 3 0 12 3 11 7 -2输出样例1：11说明对于60%的数据：N &lt;= 10,000 对于100%的数据：N &lt;= 200,000 对于所有数据 -1,000 &lt;= A[i] &lt;= 1,000且1 &lt;= L &lt;= R &lt;= N 题解看了题后不难想到这个题是个dp，而状态转移方程为dp[i] = max(dp[k]) (k &gt;=i+l &amp;&amp; k &lt;= i+r) + a[i]。如果暴力去dp会多了一层（l,r)的循环，可能会超时，所以对区间(l,r)进行优化，用单调队列进行优化。维护区间【l,r】的最大值即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;typedef long long ll;const int INF = 0x3f3f3f3f;const int MAXN = 2e6+7;using namespace std;int a[MAXN];int dp[MAXN],q[MAXN]; //单调队列存的是下标 int main() &#123; int n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; for(int i = 0;i &lt;= n;i++) cin &gt;&gt; a[i]; int head = 1,tail = 0,p = 0; int ans = -1; memset(dp,-1,sizeof(dp)); //对于所有的点初始值都为最小 dp[0] = 0;//在0点为0 for(int i = l;i &lt;= n;i++)&#123; //从0开始，第一个能跳的点就是l,往后依次判断 while(head &lt;= tail &amp;&amp; dp[q[tail]] &lt; dp[p]) tail--; //如果当前队列内的值小于最新的值，直接把他删去即可 tail++; q[tail] = p;//记录是第几个入队的 if(q[head] + r &lt; i) //如果此时队头的下标加上r比i小，要把队头删去 head++; dp[i] = dp[q[head]] + a[i]; p++; &#125; for(int i = n-r+1;i &lt;= n;i++) //对于能跳到对岸的点找一个最大值即可 ans = max(ans,dp[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/categories/动态规划/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"toSplay","slug":"toSplay","date":"2018-09-12T13:00:00.000Z","updated":"2019-07-14T11:50:25.683Z","comments":true,"path":"2018/09/12/toSplay/","link":"","permalink":"http://yoursite.com/2018/09/12/toSplay/","excerpt":"故事伊始曾经想把代码精简，到最后AC才发现。 这代码字里行间，全部都是你。 –zzzhy","text":"故事伊始曾经想把代码精简，到最后AC才发现。 这代码字里行间，全部都是你。 –zzzhy 你看这颗可爱的线段树，它可以这样转，这样转，再这样转……..","categories":[],"tags":[{"name":"人民艺术家 zzzhy","slug":"人民艺术家-zzzhy","permalink":"http://yoursite.com/tags/人民艺术家-zzzhy/"}]}]}