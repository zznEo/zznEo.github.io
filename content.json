{"meta":{"title":"Never Give Up!","subtitle":11,"description":null,"author":"nEo.大魔王","url":"http://yoursite.com","root":"/"},"pages":[{"title":"ABOUT","date":"2019-07-11T13:05:04.000Z","updated":"2019-07-31T07:32:06.710Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Me 蒟蒻ACMer&nbsp;|&nbsp;C++&nbsp;|&nbsp;数据结构&nbsp;|&nbsp;算法 Timeline 人生经历 2018.09.07 &nbsp;&nbsp;&nbsp; 考入NYIST 2019.02.28 &nbsp;&nbsp;&nbsp; Fall in love with her 比赛经历 2018.10.27 &nbsp;&nbsp;&nbsp; 加入软院ACM集训队 2019.01.05 &nbsp;&nbsp;&nbsp; 郑州轻工业大学–“卓见杯” 河南省高校邀请赛 金奖 兴趣 2019.07.14 &nbsp;&nbsp;&nbsp; 迁移 Blog 至公网服务器 To Honorary Man这个网站的搭设离不开我的好学长，ACM的好队员，人民群众的好榜样: &nbsp; zzzhy他确实是一名德艺双馨的人民老艺术家，在这段时间给了我很多帮助。没有&nbsp;zzzhy，就不会有这个网站。感谢他。阿门。"},{"title":"标签","date":"2019-07-14T08:02:32.000Z","updated":"2019-07-14T11:54:21.401Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-14T08:02:25.000Z","updated":"2019-07-14T11:54:01.166Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"NYIST-SW-ACM集训队招新介绍","slug":"关于ACM","date":"2022-07-31T05:49:05.000Z","updated":"2019-08-12T09:03:58.276Z","comments":true,"path":"2022/07/31/关于ACM/","link":"","permalink":"http://yoursite.com/2022/07/31/关于ACM/","excerpt":"Q：想锻炼自己的编程能力？ Q：想与全世界的算法爱好者切磋？ Q：想在工作、考研中获得优势？ Q：想不虚度大学光阴，找到可以奋斗四年的目标？ Q：想成为 Legendary Grandmaster（大佬）？ A：欢迎加入 软件学院 ACM 集训队! 你离精英只差一个 ACM的距离！","text":"Q：想锻炼自己的编程能力？ Q：想与全世界的算法爱好者切磋？ Q：想在工作、考研中获得优势？ Q：想不虚度大学光阴，找到可以奋斗四年的目标？ Q：想成为 Legendary Grandmaster（大佬）？ A：欢迎加入 软件学院 ACM 集训队! 你离精英只差一个 ACM的距离！ 什么是ACM？ACM 国际大学生程序设计竞赛（英文全称：ACM International Collegiate Programming Contest，简称 ACM-ICPC 或 ICPC）是由国际计算机协会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近 40年的发展，ACM 国际大学生程序设计竞赛已经发展成为全球最具影响力的大学生程序设计竞赛。赛事目前由 IBM 公司赞助。2017 年教育部发布《中国高校创新人才培养暨学科竞赛评估结果》，ACM-ICPC 是十九项竞赛评估指标中，唯一入选的计算机程序设计类竞赛，足以可见其对于大学生学科创新能力培养的重要性。 收获奖项的同时，玩 ACM 竞赛到底会给我们带来哪些益处呢？让我们一一道来： 不管在什么时候，算法都是计算机科学领域最重要的基石之一。ACMer扎实的算法基础和编程能力更受企业青睐。 据非官方统计，在 ACM 区域赛上拿到铜牌 20W 年薪的工作妥妥的，银牌 30W，金牌 50W 到无上限，但归根结底还是要自己努力付出，才会有收获。(薪资仍在不断上升！) 软件ACM集训队是我校竞争力最强的工作室之一，每年软件ACM集训队都会派出队伍参加ACM亚洲区域赛，国赛，省赛以及各种程序设计竞赛，并多次取得不俗的成绩。 玩 ACM， C 程序设计、数据结构、算法、离散数学等等这些对于大多数同学有难度的课程直接躺过，拿高分也很容易。 软件ACM集训队提供了一个良好的学习环境，学习，其实最重要的是环境。 与全国各大高校同台竞技，开阔视野，让你见识到这个领域内最牛逼的那一批同龄人是怎样的水准，自己距离他们有多大的差距。 很多往届学长在 BAT 腾讯 百度 旷视 字节跳动 等知名公司就职，会有很多内推机会。 考研的面试、笔试、上机，对于 ACMer 来说，小儿科。学好算法，对以后的深造有极大帮助，研究生导师都很喜欢算法 NB的学生。ps:目前真正打到大三的ACM成员除考研无一人不是在大厂工作，从集训队出去实习期日薪低于300都是种耻辱！ 在ACM集训队中学习，学到的不仅仅是相关的算法知识，更重要的是学到了能自主学习，自主攻克难关的能力。强大的学习能力在任何地方都是适用的。 玩 ACM 可以结交很多来自全国其他各个高校的朋友，而且都是精英中的精英。自行脑补与清华、北大等学校同台竞技的感觉！ 公费旅游 每年的区域赛都在全国各地举办，例如北京（烤鸭）、青岛（大虾）、沈阳（乱炖）、杭州（醋鱼）、西安（肉夹馍）……，在不同的城市、不同的大学比赛，可以感受不同的文化。 软件学院 ACM-ICPC 实训室 依托于南阳理工学院软件学院，ACM-ICPC 实训室重建与2015年，从刚开始的 3、4 个人发展到目前稳定 40 人左右的规模。实验室现位于南阳理工学院软件学院五楼中 507 510 512 房间。拥有集训队自己的训练地方，不仅可供集训队内成员平日训练，也可退役后在这里考研，深造。且集训室内拥有自己的冰箱！。 历经 5 年，实验室在 ACM-ICPC 亚洲区域赛、 ACM-CCPC 分站赛、中国高校天梯赛、蓝桥杯、河南省赛等国际、国家、省级各类比赛中斩获金、银、铜百余奖项。前方有一大批图片来袭： 下面最关键的问题来了，到底如何加入 ACM 集训队呢？集训队遵循公平公正的选拔原则，不论年级、专业，只要参加ACM集训队线下招新赛成绩较好，有能力、激情、肯吃苦的同学就可以加入集训队。有同学说，我能力不够怎么办。咱们说，不用着急，只要你踏实努力了，我们每年有多次选拔的机会在等你! 我们会在军训结束后进行简单的C语言培训，国庆期间也会组织有关C语言和简单算法的集训，所有人都可以报名参加。不要担心零基础的问题，我们保证讲到你们听懂为止。我们会在集训后举办一系列的招选拔赛和月赛，根据名次来决定具体的人选，具体请加入2019软件ACM迎新群:791901837 闲谈首先,我们都应该清楚,南阳理工学院作为一个双非院校(中原小清华),我们的形式是非常严峻的。计算机行业是当下的热门行业,它很好就业,且薪资待遇良好。可仔细想想,每年985 211 双一流院校的计算机,软件相关毕业生多的不计其数,那些知名企业为什么要选择一个资历平平的你进入公司,去拿这份高薪?你们应该都听说过996的工作制,也都听说过程序员就是新世纪的农民–码农,也都听说过程序员行业寿命短,中年失业等等等等。这也是大多数程序员的通病。可是如今人工智能产业火爆,AI技术越来越精进,计算机类产业的高端人才严重缺失,但中低端技术人员缺已经饱和。大批的算法岗位空缺,且薪资待遇都优于其他开发岗位。可以在任何求职网站上搜索算法工程师,他们的薪资都是非常诱人的。 而在我院,ACM集训队是唯一一个教授算法的地方,也是唯一一个能让你成为算法工程师的地方。不要听言ACM集训队只会刷题,不会做项目,后面找不到工作。这一切都是无稽之谈。你能想象到,你在公司实习时能接触到的项目,和你在学校内的项目能学到的东西是没有可比性的!算法是程序之根本,你能掌握程序的核心还怕找不到工作么?那些项目相关的知识对于学习能力强大的ACMer来说真的易如反掌。15级学长 ps:(你觉得学会一种语言需要多久? 七天就够)对于双非院校的我们来说ACM绝对是一条逆袭的道路,它让我们未来在职场能和 985 211 双一流院校毕业的学生一样有着同等的竞争力。加入软件学院ACM集训队,挑战自己,成就自己! 其他 首先感谢人民艺术家:zzzhy先生的技术支持,及文章推送 不论是学习，生活还是什么方面的问题都会有学长学姐耐心解答。 如果高中有信息学竞赛（OI）的经历，可以直接联系我们 最终解释权归南阳理工学院软件学院ACM集训队所有","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"Codeforces Round#595解题报告","slug":"Codeforces Round #595解题报告","date":"2019-10-24T11:10:00.000Z","updated":"2019-10-24T11:44:08.300Z","comments":true,"path":"2019/10/24/Codeforces Round #595解题报告/","link":"","permalink":"http://yoursite.com/2019/10/24/Codeforces Round #595解题报告/","excerpt":"从大一到现在补过题目的最多的一场 $CF$ ，决定写一篇解题报告纪念一下。","text":"从大一到现在补过题目的最多的一场 $CF$ ，决定写一篇解题报告纪念一下。 A.Yet Another Dividing into Teams题意给定一个序列，问你需要把这个序列分成多少段，才能保证每一段中的所有数字他们的差值都严格大于1 题解数据范围较小，直接 $set$ 暴力，记录有多少个 $set$ ，然后把 $set$ 里面的元素从大到小排序，把原序列排序，直接判定第一个每个 $set$ 里面的第一个元素是否符合条件即可。可能我写的比较复杂？第一眼感觉像是导弹拦截那个题 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e3+7;int a[MAXN];set&lt;int&gt; S[MAXN];int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++) cin &gt;&gt; a[i]; sort(a+1,a+1+n); int cnt = 1; S[cnt].insert(-a[1]); for(int i = 2;i &lt;= n;i++)&#123; //set&lt;int&gt;::iterator it; bool flag = true; for(int j = 1;j &lt;= cnt;j++)&#123; if(a[i] - -*S[j].begin() &gt; 1)&#123; S[j].insert(-a[i]); flag = false; break; &#125; &#125; if(flag)&#123; cnt++; S[cnt].insert(-a[i]); &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for(int i = 1;i &lt;= cnt;i++) S[i].clear(); &#125; return 0;&#125; B.Books Exchange题意$B1,B2$ 题意相同，只是 $n$ 的数据范围不同。给定一个序列，代表，第 $i$ 个人每天都会把自己手中的书传递给第 $a_i$ 这号人，问每个人最少在第多少天会受到自己原来的那本书。 题解很像洛谷的一道题，忘了是啥了。直接 $dfs$ 判环，对于 $B1$ ，直接暴力枚举 $i$ 每次都去 $dfs$ 就行，而对于 $B2$，需要记录一下这个环上所有的点的天数，因为同一个环，所有人收到书的时间是一样的 代码12345678910111213141516171819202122232425262728293031323334353637383940// B1#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e3+7;vector&lt;int&gt; V[MAXN];bool flag;void dfs(int s,int x,int sum)&#123; if(flag)&#123; cout &lt;&lt; sum &lt;&lt; \" \"; return ; &#125; for(int i = 0;i &lt; V[x].size();i++)&#123; if(s == V[x][i]) flag = true; dfs(s,V[x][i],sum+1); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,v; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; v; V[i].push_back(v); &#125; for(int i = 1;i &lt;= n;i++)&#123; flag = false; dfs(i,i,0); &#125; cout &lt;&lt; endl; for(int i = 1;i &lt;= n;i++) V[i].clear(); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//B2#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 2e5+7;const int INF = 0x3f3f3f3f;vector&lt;int&gt; V[MAXN];int a[MAXN],sum;bool flag;void dfs(int s,int x)&#123; if(flag)&#123; a[s] = sum; return ; &#125; for(int i = 0;i &lt; V[x].size();i++)&#123; if(s == V[x][i]) flag = true; sum++; dfs(s,V[x][i]); a[V[x][i]] = sum; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,v; cin &gt;&gt; n; memset(a,INF,sizeof(a)); for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; v; V[i].push_back(v); &#125; for(int i = 1;i &lt;= n;i++)&#123; flag = false; sum = 0; if(a[i] == INF) dfs(i,i); &#125; for(int i = 1;i &lt;= n;i++)&#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //memset(a,INF,sizeof(a)); for(int i = 1;i &lt;= n;i++) V[i].clear(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/tags/Codeforces/"}]},{"title":"Luogu-1282-多米诺骨牌","slug":"Luogu 1282 多米诺骨牌","date":"2019-10-21T12:29:39.000Z","updated":"2019-10-22T05:18:23.879Z","comments":true,"path":"2019/10/21/Luogu 1282 多米诺骨牌/","link":"","permalink":"http://yoursite.com/2019/10/21/Luogu 1282 多米诺骨牌/","excerpt":"多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。例如在图8-1中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。 对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。","text":"多米诺骨牌有上下2个方块组成，每个方块中有1~6个点。现有排成行的上方块中点数之和记为S1，下方块中点数之和记为S2，它们的差为|S1-S2|。例如在图8-1中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。 对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。 题目链接Luogu-1282-多米诺骨牌 输入输出格式输入格式输入文件的第一行是一个正整数 $n(1 \\leq n \\leq 1000)$ ，表示多米诺骨牌数。接下来的n行表示 $n$ 个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数 $a$ 和 $b$，且 $1\\leq a，b \\leq 6$ 。 输出格式输出一行，为世界末日的日期，每个数字之间用一个空格隔开。 输入输出样例输入样例1：1234546 11 51 31 2 输出样例1：1题解很显然是个 dp 题目，显然蓝题 dp 我不会写，自己瞎定义了一个 $dp[i][j]$ ，发现没法进行状态转移，看了题解说我定义的方程太麻烦很难写？？？？喵喵喵？？？然后看了题解的 $dp$ 的定义方法，写了下去。 一开始我定义的 $dp[i][j]$ 是前 $i$ 个牌，翻转 $j$ 次的上下差值。我不会推状态转移方程，后期刷多了再推把。 题解的定义为 $dp[i][j]$ 代表前 $i$ 个牌组成和为 $j$ 的旋转次数。对于这种定义，我们可以暴力枚举，前 $i$ 能组成的所有和，即 $dp[i][j] = min(dp[i][j],dp[i-1][j - a[i]]) // 不翻转$$dp[i][j] = min(dp[i][j],dp[i-1][j - b[i]] + 1) // 翻转$ 对于 $j$ 而言，前 $i$ 个骨牌所能组成的最大总和为 $6 * n$ ，所以时间复杂度为 $O(6*n^2)$ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 3e3 + 5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int dp[1005][6005];int a[MAXN],b[MAXN];int main() &#123; ios::sync_with_stdio(false); int n,sum = 0; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; sum += a[i] + b[i]; &#125; memset(dp,INF,sizeof(dp));//最初所有能组成的点数之和的翻转次数都是INF dp[1][a[1]] = 0;dp[1][b[1]] = 1; //第一块骨牌的上为0，下为1 for(int i = 2;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= 6*n;j++)&#123; if(j &gt;= a[i]) dp[i][j] = min(dp[i][j],dp[i-1][j - a[i]]); if(j &gt;= b[i]) dp[i][j] = min(dp[i][j],dp[i-1][j - b[i]] + 1); &#125; &#125; int cut = INF,cnt = INF; for(int i = 1;i &lt;= sum;i++)&#123; if(dp[n][i] != INF)&#123; //如果这n个牌能到达和为i if(cut &gt; abs(i - (sum - i)))&#123; cut = abs(i - (sum - i)); cnt = dp[n][i]; &#125; else if(cut == abs(i - (sum - i)))&#123; cnt = min(cnt,dp[n][i]); &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"Luogu-1140-相似基因","slug":"LuoguP1140 【相似基因】","date":"2019-10-16T00:30:00.000Z","updated":"2019-10-16T09:32:27.012Z","comments":true,"path":"2019/10/16/LuoguP1140 【相似基因】/","link":"","permalink":"http://yoursite.com/2019/10/16/LuoguP1140 【相似基因】/","excerpt":"大家都知道，基因可以看作一个碱基对序列。它包含了 $44$ 种核苷酸，简记作 $A,C,G,T$ 。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。 在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。","text":"大家都知道，基因可以看作一个碱基对序列。它包含了 $44$ 种核苷酸，简记作 $A,C,G,T$ 。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。 在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。 两个基因的相似度的计算方法如下：对于两个已知基因，例如 $AGTGATG$ 和 $GTTAG$ ，将它们的碱基互相对应。当然，中间可以加入一些空碱基 $-$ ，例如： 这样,两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示： 那么相似度就是：$(-3) + 5 + 5 + (-2) + (-3) + 5 + (-3) + 5= 9$。因为两个基因的对应方法不唯一，例如又有： 相似度为：$(-3) + 5 + 5 + (-2) + 5 + (-1) + 5 = 14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。 题目链接Luogu-1140-相似基因 输入输出格式输入格式：共两行。每行首先是一个整数，表示基因的长度；隔一个空格后是一个基因序列，序列中只含 $A,C,G,T$ 四个字母。$1 \\le 序列的长度\\le 100$ 输出格式：仅一行，即输入基因的相似度。 输入输出样例输入样例：7 AGTGATG 5 GTTAG输出样例：14题解看完这个题，完全没思路，想着看题解寻求一些帮助吧，看完题解还是***不会。又多看了两篇，尽量描述懂吧(好留给后面我自己看)。 首先这是一道很明显的 $dp$ ，定义 $dp[i][j]$ 代表第一个序列的前 $i$ 个碱基，与第二个序列的前 $j$ 个碱基的最大值例如： 7 AGTGATG5 GTTAG$dp[2][3]$ 代表的就是 $AG$ 与 $GTT$ 相对应的最大值dis(i，j)表示a[i] 与 b[j] 的相似度关于状态转移方程的定义： $dp[i][j] = max(dp[i][j],dp[i-1][j-1] + dis(i,j))$ $dp[i][j] = max(dp[i][j],dp[i-1][j] + dis(i,4))$ $dp[i][j] = max(dp[i][j],dp[i][j-1] + dis(j,4))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e3 + 5;const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;int a[MAXN],b[MAXN];int dp[MAXN][MAXN];int n,m;string s1,s2;const int tab[5][5]=&#123; &#123;5,-1,-2,-1,-3&#125;, &#123;-1,5,-3,-2,-4&#125;, &#123;-2,-3,5,-2,-2&#125;, &#123;-1,-2,-2,5,-1&#125;, &#123;-3,-4,-2,-1,0&#125;&#125;;void init()&#123; for(int i = 1;i &lt;= n;i++)&#123; if(s1[i-1] == 'A') a[i] = 0; else if(s1[i-1] == 'C') a[i] = 1; else if(s1[i-1] == 'G') a[i] = 2; else a[i] = 3; &#125; for(int i = 1;i &lt;= m;i++)&#123; if(s2[i-1] == 'A') b[i] = 0; else if(s2[i-1] == 'C') b[i] = 1; else if(s2[i-1] == 'G') b[i] = 2; else b[i] = 3; &#125; for(int i = 1;i &lt;= n;i++) for(int j = 1;j &lt;= m;j++) dp[i][j] = -INF; for(int i = 1;i &lt;= n;i++) dp[i][0] = dp[i-1][0] + tab[a[i]][4]; for(int i = 1;i &lt;= m;i++) dp[0][i] = dp[0][i-1] + tab[4][b[i]];&#125;int main() &#123; ios::sync_with_stdio(false); int n,m; string s1,s2; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; m &gt;&gt; s2; init(); for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; dp[i][j] = max(dp[i][j],dp[i][j-1] + tab[b[j]][4]); dp[i][j] = max(dp[i][j],dp[i-1][j] + tab[a[i]][4]); dp[i][j] = max(dp[i][j],dp[i-1][j-1] + tab[a[i]][b[j]]); &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"}]},{"title":"2019年软件计科国庆新生联和赛题解","slug":"2019年软件计科国庆新生联和赛题解","date":"2019-10-07T06:00:00.000Z","updated":"2019-10-16T00:49:18.467Z","comments":true,"path":"2019/10/07/2019年软件计科国庆新生联和赛题解/","link":"","permalink":"http://yoursite.com/2019/10/07/2019年软件计科国庆新生联和赛题解/","excerpt":"种种原因主要是计科的锅，比赛计科前的题目过于儿戏，$rand$ 的题目都往上放，$TC$ 数据只挂输入没挂输出，由于没网，离线 $OJ$ 不能重测，不能删题，全场所有人白给一道题，不过还好没有人因为罚时比别人名次低(前几)。不管软件这次出题真的是面面俱到了，希望大家认真补题。","text":"种种原因主要是计科的锅，比赛计科前的题目过于儿戏，$rand$ 的题目都往上放，$TC$ 数据只挂输入没挂输出，由于没网，离线 $OJ$ 不能重测，不能删题，全场所有人白给一道题，不过还好没有人因为罚时比别人名次低(前几)。不管软件这次出题真的是面面俱到了，希望大家认真补题。 题目分析 题目分布：软件-ACM集训队 A B C D题，计科-ACM工作室 I J K L 题，计科 - TC工作室 E F G H题 题目难度： 签到题： $A,G,J$防 $AK$ 题：$C,I,L$其余题目均为一般题 补题链接点这里 A. Apple 大法好题解显然，最大值是 $m,k$ 的最小值。而对于最小值而言，当 $m+k \\leq n$ 时，此时最少的人数应该为 $0$ ，很多人没注意到这一点。当 $n \\leq m+k $ 时，此时直接输出 $m+k - n$ 即可。 标程时间复杂度:$O(1)$ 123456789101112131415161718#include&lt;stdio.h&gt;int main() &#123; int n; while(scanf(\"%d\",&amp;n) !=EOF) &#123; int m,k; scanf(\"%d %d\",&amp;m,&amp;k); int MAX; if(m &lt; k) MAX = m; else MAX = k; int ans = n - (m + k); if(ans &lt; 0) printf(\"%d %d\\n\",MAX,-ans); else printf(\"%d 0\\n\",MAX); &#125;&#125; B. wbt和wpm的博弈游戏题解仔细读题不难发现说了一堆废话只需要判断 $n,m$ 的关系即可。注意输出的是$N0$ 不是 $NO$ 。 标程时间复杂度:$O(1)$ 123456789101112131415161718#include&lt;stdio.h&gt;const int N = 1010;int a[N], b[N];int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d\", &amp;b[i]); &#125; if (n &gt; m) printf(\"YES\\n\"); else printf(\"N0\\n\"); return 0;&#125; C. 到底谁是510最懒的？题解两层 $for$ 循环,第一层枚举每个人，第二层枚举每个人之前有多少个比他懒的人直接输出即可。 标程时间复杂度:$O(n^2)$ 123456789101112131415#include&lt;stdio.h&gt;int main() &#123; int n, a[1005], b = 0; scanf(\"%d\", &amp;n); for(int i = 0;i &lt; n;i++) scanf(\"%d\",&amp;a[i]); for(int i = 0;i &lt; n;i++) &#123; for(int j = i - 1;j &gt;= 0;j--) if(a[i] &gt; a[j]) b++; printf(\"%d \",b); b = 0; &#125; return 0;&#125; D. why挤公交理论上的防 $AK$ 题。 题解太刁民了 标程时间复杂度:$O(n)$ 123456789101112131415#include &lt;iostream&gt;using namespace std;const int maxn = 1e4 + 10;int aa[maxn], bb[maxn];int main() &#123; int a, n, m, x; scanf(\"%d %d %d %d\",&amp;a,&amp;n,&amp;m,&amp;x); aa[1] = 0, aa[2] = 1, aa[3] = 2; for(int i = 4; i &lt; n; i++) &#123; aa[i] = aa[i - 1] + aa[i - 2] - 1; bb[i] = bb[i - 1] + bb[i - 2] + 1; &#125; int b = (m - aa[n - 1] * a) / bb[n - 1]; printf(\"%d\\n\",aa[x] * a + bb[x] * b);&#125; 感受算法的魅力你们学完二分以后可以再回头看这个题目，这里提供一种二分的解法。 直接暴力枚举第二站的上下车人数 $x$ 然后每次都去循环判断，到第 $n$ 站是否满足题目中的 $m$，如果满足这个 $x$ 就是我们要找的。如果按照我们枚举的 $x$ 得到的答案比题目中最后一站的人多则缩小 $x$ 的范围，否则增大，这样最终我们会得到一个满足题意的 $x$ 然后直接输出所求即可。 标程2时间复杂度:$O(n*log{n})$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5+7;const int INF = 0x3f3f3f3f;long long up[MAXN],down[MAXN],a[MAXN];int n,m,x;int judge(int mid) &#123; up[1] = a[1],up[2] = mid; down[1] = 0,down[2] = mid; for(int j = 3; j &lt;= n; j++) &#123; up[j] = up[j-1] + up[j-2]; down[j] = up[j-1]; a[j] = a[j-1] + up[j] - down[j]; &#125; if(a[n-1] == m) &#123; cout &lt;&lt; a[x] &lt;&lt; endl; return 2; &#125; else if(a[n-1] &gt; m) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; a[1] &gt;&gt; n &gt;&gt; m &gt;&gt; x; if(x == 1 || x == 2) &#123; cout &lt;&lt; a[1] &lt;&lt; endl; return 0; &#125; a[2] = a[1]; int L = 0,R = INF; while(L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; int ans = judge(mid); if(ans == 2) &#123; return 0; &#125; else if(ans == 0) &#123; L = mid + 1; &#125; else &#123; R = mid - 1; &#125; &#125; return 0;&#125; E.一道快乐的水题题解：只需要看当前指针指着的字母离下一个字母顺时针旋转近还是逆时针旋转近，最后把每次拧的次数加起来就行了。 标程12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;char ss[1000];int main() &#123; scanf(\"%s\", ss); int sum = 0; char index = 'a'; for (int i = 0; i &lt; strlen(ss); i++) &#123; int num = index - ss[i]; if (num &lt; 0) num += 26; if (num &gt; 13) num = 26 - num; sum += num; index = ss[i]; &#125; printf(\"%d\\n\", sum); return 0;&#125; F.最简单的签到题题解暖心签到竟成了劝退打法？ 大水题，但是要注意“！”是中文的感叹号，复制粘贴输出就可以了。 标程12345#include&lt;stdio.h&gt;int main() &#123; printf(\"Hello World ！\\n\"); return 0;&#125; G.来自步步的疑惑题解从给定的坐标中找出上下左右的最值，作为矩形的上下左右边界，就可以求出矩形左上角和右下角的坐标。 标程1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int flag = 1; while (flag) &#123; flag = 0; int x, y, Left = 1e6 + 5, Right = -1e6 - 5, Up = -1e6 - 5, Down = 1e6 + 5; while (~scanf(\"%d %d\", &amp;x, &amp;y)) &#123; if (x == 0 &amp;&amp; y == 0) break; flag = 1; Left = min(Left, x), Right = max(Right, x); Down = min(Down, y), Up = max(Up, y); &#125; if (flag) printf(\"%d %d %d %d\\n\", Right, Up, Left, Down); &#125; return 0;&#125; H.dch与lgp学弟的刁难题解我们可以这么想数组的下标看作x轴，对应的值看作y轴，那么区间值就是以下标和对应值作为坐标的区间左右边界的距离。那么求区间值的最小值就是求左右边界坐标的直线距离，也就是不进行任何拆分时的值。（数据范围会炸int） 标程123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;long long arr[1000005];int main() &#123; int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%lld\", &amp;arr[i]); for (int i = 1; i &lt;= m; i++) &#123; long long x, y; scanf(\"%lld %lld\", &amp;x, &amp;y); double ans = sqrt((y - x) * (y - x) + (arr[x] - arr[y]) * (arr[x] - arr[y])); printf(\"%.3lf\\n\", ans); &#125; return 0;&#125; I.三角形 ？矩形？题解由于是矩形，那么必须是两个全等的直角三角形才能构成矩形。按从大到小排序，判断是否三个边都相等，其次判断a[0]*a[0]+a[1]*a[1]==a[2]*a[2]即可判断能否构成直角三角形 标程1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;void Bubble_Sort(int a[], int len) &#123; int temp; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125;int main() &#123; int a[3], b[3], i, ans = 0; for (i = 0; i &lt; 3; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (i = 0; i &lt; 3; i++) &#123; scanf(\"%d\", &amp;b[i]); &#125; Bubble_Sort(a, 3); Bubble_Sort(b, 3); for (i = 0; i &lt; 3; i++) &#123; if (a[i] == b[i]) ans++; &#125; if (ans == 3) &#123; if (a[0] * a[0] + a[1] * a[1] == a[2] * a[2]) &#123; printf(\"Yes\\n\"); &#125; else &#123; printf(\"No\\n\"); &#125; &#125; else &#123; printf(\"No\\n\"); &#125; return 0;&#125; 当然可以用更高效的排序，或者直接枚举全部情况 J.国庆集训题解题意可能很难读懂（预计的水题导致没人出 背锅），但是：可以将时间看作一个区间寻找规律： $[1,n]$：学姐0 $[n+1,m+n]$：学姐1 $[m+n+1,2n+1]$：学姐0 $[2n+2,m+2n+1]$：学姐1 $[m+2n+2,3n+2]$：学姐0 $[3n+3,m+3n+2]$：学姐1……不难发现，除了第一次长度为$m+n$以外其余区间的长度均为$n+1$ 故分两种情况: $t\\leq m+n$时，$[1,n]$为学姐0，$[n+1,m+n]$为学姐1。 $t&gt;m+n$时，对每一个周期$n+1$内，前$n-m+1$天是学姐0，后$m$天是第学姐1。 标程123456789101112131415161718192021#include &lt;stdio.h&gt;int main() &#123; int T, n, m, q, t; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); while (q--) &#123; scanf(\"%d\", &amp;t); if (t &gt; n + m) &#123; t = t - (n + m); if (t % (n + 1) != 0) t = t % (n + 1); else t = n + 1; printf(\"%d\\n\", t &gt; n - m + 1); &#125; else printf(\"%d\\n\", t &gt; n); &#125; &#125; return 0;&#125; K.爱的魔力转圈圈题解 首先：得知道相切的时候数量最小 其次：我们只需要算每一个R球最大能占r球圆心角360°的多少°，如图：根据题目提示和上图不难知道，答案将向上取整即可。 标程12345678910#include &lt;math.h&gt;#include &lt;stdio.h&gt;const double pi = 3.141593;double r, R;int main()&#123; while(~scanf(\"%lf%lf\",&amp;r,&amp;R))&#123; printf(\"%d\\n\", (int)ceil(pi / asin(R / (r + R)))); &#125; return 0;&#125; L.nuoyanli会打印图形题解对于打印图形的题，使用平面几何知识也是很简单的； 标程1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int a, b; int n; while (~scanf(\"%d\", &amp;n)) &#123; for (a = 0; a &lt; (4 * n - 3); a++) &#123; for (b = 0; b &lt; (6 * n - 5); b++) &#123; if ((a == (3 * n - 3 - b)) || (a == (b - 3 * n + 3)) || (a == (b + n - 1)) || (a == (7 * n - 7 - b)) || (a == n - 1) &amp;&amp; (b % 2 == 0) || (a == 3 * n - 3) &amp;&amp; (b % 2 == 0)) printf(\"*\"); else if ((a &gt; (3 * n - 3)) &amp;&amp; (a &gt; (7 * n - 7 - b)) || (a &lt; n - 1) &amp;&amp; (a &lt; (b - 3 * n + 3))) continue; else if ((a &gt; (3 * n - 3 - b)) &amp;&amp; (a &gt; (b - 3 * n + 3)) || (a &gt; (b - 3 * n + 3)) &amp;&amp; (a &lt;= (3 * n - 1)) || (a &lt; (7 * n - 7 - b))) printf(\" \"); &#125; printf(\"\\n\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 感谢 王启宇 为我们提供详细的题解：https://blog.csdn.net/nuoyanli/article/details/102456178，至于for一行一行暴力找规律的代码就不贴出来了。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"月赛","slug":"月赛","permalink":"http://yoursite.com/tags/月赛/"}]},{"title":"NYIST_SW_ACM 第二次常规月赛解题报告","slug":"NYIST-第二次常规月赛解题报告","date":"2019-09-23T05:15:20.000Z","updated":"2019-09-24T11:21:12.654Z","comments":true,"path":"2019/09/23/NYIST-第二次常规月赛解题报告/","link":"","permalink":"http://yoursite.com/2019/09/23/NYIST-第二次常规月赛解题报告/","excerpt":"失败的月赛","text":"失败的月赛 A. CRY翩翩起舞一道超级难的证明的签到题（求偏导）？？实际上大胆猜结论就能过。 题意给你 $ n $ 个点，让你找到一个点使这个点到所有点的平方距离 (欧几里得距离) 和最小。 题解场上卡死，不知道怎么解，场下看了题解不知道怎么证明。用了模拟退火，三分套三分的板子，都过不去。不知道为啥求了费马点，也过不去，可能精度？用这个公式 $ \\LARGE x = \\frac{\\sum_{i = 1}^{n}x_i}{n}\\ $ $\\LARGE y = \\frac{\\sum_{i = 1}^{n}y_i}{n}$，求得一个 $ x, y $，然后套欧几里得公式即可。我也不知道为啥。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1E5+7;typedef long long ll;struct Point&#123; double x,y;&#125;DATA[MAXN],p;double dis(Point a,Point b)&#123; return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);&#125;int main() &#123; int n; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; DATA[i].x &gt;&gt; DATA[i].y; p.x += DATA[i].x; p.y += DATA[i].y; &#125; p.x /= n; p.y /= n; double ans; for(int i = 1;i &lt;= n;i++)&#123; ans += dis(p,DATA[i]); &#125; printf(\"%.2f\\n\",ans); return 0;&#125; B. CRY痛哭流涕待补 C. CRY推命题题意给你一堆命题的关系，用矩阵的 $i，j$ 表示。$0$ 代表不确定 $i,j$ 的关系 ，$1$ 代表 $i \\to j$，$-1$ 代表 $i$ 无法推出 $j$ 。问最少需要确定几个 $0$ 的关系才能确定 $ 1 \\to n\\ $ ，否则输出 $-1$. 题解正解应该是 $O(n)$ 的 $ 01BFS $，但是数据难造，$O(n*logn))$的最短路也可过。对与这张图，我们对关系为 $1$ 的 $i \\to j$ 建花费为$0$ 的边， 对关系为 $0$ 的 $i \\to j$ 建造花费为 $1$ 的边，剩余的都设为 $INF$。跑整张图的最短路即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;const int MAXN = 2e5 + 5;const int INF = 0x3f3f3f3f;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; edge[MAXN];bool vis[MAXN];int dist[MAXN];void dijkstra(int n) &#123; memset(dist, INF, sizeof(dist)); memset(vis, false, sizeof(vis)); priority_queue&lt;pair&lt;int, int&gt; &gt; que; que.push(make_pair(0, 1)); dist[1] = 0; while (!que.empty()) &#123; int u = que.top().second; que.pop(); if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; edge[u].size(); i++) &#123; int v = edge[u][i].first; if (dist[v] &gt; dist[u] + edge[u][i].second) &#123; dist[v] = dist[u] + edge[u][i].second; que.push(make_pair(-dist[v], v)); &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; edge[i].clear(); for (int j = 1; j &lt;= n; j++) &#123; int op; cin &gt;&gt; op; if (i == j) continue; if (op == 0) &#123; edge[i].push_back(make_pair(j, 1)); &#125; else if (op == 1) &#123; edge[i].push_back(make_pair(j, 0)); &#125; &#125; &#125; dijkstra(n); cout &lt;&lt; dist[n] &lt;&lt; endl; &#125;&#125; D. CRY的住宿计划题意找到一个 $0$ 的位置，使这个 $0$ 的位置到其他 $K$ 个 $0$ 的位置切比雪夫距离最大值最小 两点 $(x_1,y_1)\\ (x_2,y_2)$ 的切比雪夫距离为 $max(abs(x_1-x_2),abs(y_1-y_2))$ ，其中 $abs()$为绝对值函数。 题解暴力枚举每个点，二分切比雪夫距离，用二维前缀和快速查询当前矩形中 $0$ 的个数 时间复杂度 $O(n^{2}\\ast logn)$还有一中 $O(n^{2} + logn ^ {2})$ 的写法，后期再补 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1E5+7;const int MOD = 998244353;const int INF = 0x3f3f3f3f;int n,m,k;int dp[1005][1005];char Map[1005][1005];bool judge(int x,int y,int mid)&#123; int a = max(1,x - mid),b = max(1,y - mid); int c = min(n,x + mid),d = min(m,y + mid); int num = dp[c][d] - dp[c][b-1] - dp[a-1][d] + dp[a-1][b-1]; return num &gt;= k + 1;&#125;int solve(int x,int y)&#123; int L = 0,R = max(n , m); int ans = INF; while(L &lt;= R)&#123; int mid = (L + R) &gt;&gt; 1; if(judge(x,y,mid))&#123; R = mid - 1; ans = mid; &#125; else &#123; L = mid + 1; &#125; &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1;i &lt;= n;i++)&#123; scanf(\"%s\",Map[i]+1); &#125; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + ((Map[i][j] - '0')^1); &#125; &#125; int ans = INF; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; if(Map[i][j] == '0') ans = min(ans,solve(i,j)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; E. CRY的心里阴影待补 F.CRY的最大公约数题意$T$ 组数据，$n$ 次操作，每次给定一个数，如果这个数不在当前序列内则把这个数加入这个序列，否则把这个数从序列中删去，求当前序列的最大公约数 题解直接权值线段树，离散化数据，每次更新一个链，查询 $O(1)$ 即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 4E5 + 7;typedef long long ll;int a[MAXN];int n;vector&lt;int&gt; V;struct Node &#123; int l, r; int mid() &#123; return (l + r) &gt;&gt; 1; &#125; int gcd;&#125; tree[MAXN &lt;&lt; 2];int getid(int x) &#123; return lower_bound(V.begin(), V.end(), x) - V.begin() + 1; &#125;void PushUp(int rt) &#123; if (tree[rt &lt;&lt; 1].gcd == -1 &amp;&amp; tree[rt &lt;&lt; 1 | 1].gcd == -1) tree[rt].gcd = -1; else if (tree[rt &lt;&lt; 1 | 1].gcd == -1) tree[rt].gcd = tree[rt &lt;&lt; 1].gcd; else if (tree[rt &lt;&lt; 1].gcd == -1) tree[rt].gcd = tree[rt &lt;&lt; 1 | 1].gcd; else tree[rt].gcd = __gcd(tree[rt &lt;&lt; 1].gcd, tree[rt &lt;&lt; 1 | 1].gcd); return;&#125;void Build(int l, int r, int rt) &#123; tree[rt].l = l, tree[rt].r = r; tree[rt].gcd = -1; if (l == r) return; int mid = tree[rt].mid(); Build(l, mid, rt &lt;&lt; 1); Build(mid + 1, r, rt &lt;&lt; 1 | 1);&#125;void Update(int pos, int val, int rt) &#123; if (tree[rt].l == tree[rt].r &amp;&amp; tree[rt].l == pos) &#123; if (tree[rt].gcd == -1) tree[rt].gcd = val; else tree[rt].gcd = -1; return; &#125; int mid = tree[rt].mid(); if (pos &lt;= mid) Update(pos, val, rt &lt;&lt; 1); else Update(pos, val, rt &lt;&lt; 1 | 1); PushUp(rt);&#125;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; V.clear(); Build(1, n, 1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; V.push_back(a[i]); &#125; sort(V.begin(), V.end()), V.erase(unique(V.begin(), V.end())); for (int i = 1; i &lt;= n; i++) &#123; int pos = getid(a[i]); Update(pos, a[i], 1); cout &lt;&lt; tree[1].gcd &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"月赛","slug":"月赛","permalink":"http://yoursite.com/tags/月赛/"}]},{"title":"又见01串","slug":"又见01串","date":"2019-09-04T11:28:13.000Z","updated":"2019-09-04T11:58:00.711Z","comments":true,"path":"2019/09/04/又见01串/","link":"","permalink":"http://yoursite.com/2019/09/04/又见01串/","excerpt":"给定长度为 $n$ 的 $01$ 串 $S$ ，$m$ 次询问，每次给出长度为 $w_i$ 的 $01$ 串 $Q$。求 $S$ 中和 $Q$ 长度相同且包含 $1$ 的个数相同的子串的个数","text":"给定长度为 $n$ 的 $01$ 串 $S$ ，$m$ 次询问，每次给出长度为 $w_i$ 的 $01$ 串 $Q$。求 $S$ 中和 $Q$ 长度相同且包含 $1$ 的个数相同的子串的个数 题目链接又见01串(PK找对象？？？) 输入输出格式输入格式：第一行两个整数 $n$，$m$ . 第二行字符串 $ S $. 接下来 $m$ 行，每行一个 $01$ 串 $Q$ 输出格式输出共 $m$ 行，每行一个整数 输入输出样例输入样例123457 3 1001101101010100 输出样例123340 说明$ 1 \\leq n , m \\leq 200000 $; $ 1 \\leq w_i \\leq 100 $; 凭借记忆想出来的一道题，如果找到了出处，当这篇题解没发。面对这道题，搜不到原题没有数据范围，搜不到题解只能自己慢慢猜，没有数据也没法测只能手动测，在自己能能力范围内尽可能的优化把。如有错误请指出，或更好的写法欢迎指教！QQ：2112370160 题解《根号算法不止分块》– 国家集训队论文。“根号分治”是这个题的思想。勉强算分块？题解思想类似于【 Educational Codeforces Round 71 (Rated for Div. 2) F】Remainder Problem我们把字符串长度分为大于$O(n−\\sqrt{n})$的部分和小于$O(n−\\sqrt{n})$的两个部分，对于大于的部分，我们可以发现，它最多出现$O(n−\\sqrt{n})$次，直接统计的时间复杂度就是$O(n\\sqrt{n})$，而对于小于的部分，可以在$O(n\\sqrt{n})$的时间复杂度内预处理出来。这样总的时间复杂度就是$O(m*l\\sqrt{l})$了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 2e5 + 7;const int SQRTN = sqrt(MAXN) + 7;int ans[SQRTN][SQRTN];int sum[MAXN], block;string s, q;int get(string x) &#123; int len = x.size(), ret = 0; for (int i = 0; i &lt; len; i++) if (x[i] == '1') ret++; return ret;&#125;int main() &#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; s; sum[0] = s[0] - '0'; for (int i = 1; i &lt; n; i++) &#123; sum[i] += sum[i - 1] + s[i] - '0'; &#125; block = sqrt(n); for (int i = 1; i &lt;= block; i++) &#123; for (int j = 0; j + i &lt;= n; j++) &#123; int now; if (j == 0) now = sum[i - 1]; else now = sum[j + i - 1] - sum[j - 1]; ans[i][now]++; &#125; &#125; while (m--) &#123; cin &gt;&gt; q; int len = q.size(); int need = get(q); if (len &lt;= block) &#123; cout &lt;&lt; ans[len][need] &lt;&lt; endl; &#125; else &#123; int ret = 0; for (int i = 0; i + len &lt;= n; i++) &#123; if (i == 0) &#123; if (sum[len - 1] == need) ret++; &#125; else &#123; if (sum[i + len - 1] - sum[i - 1] == need) ret++; &#125; &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"根号分治","slug":"根号分治","permalink":"http://yoursite.com/tags/根号分治/"}]},{"title":"「SNOI2017」一个简单的询问","slug":"一个简单的询问","date":"2019-08-19T03:59:31.000Z","updated":"2019-08-19T07:54:40.558Z","comments":true,"path":"2019/08/19/一个简单的询问/","link":"","permalink":"http://yoursite.com/2019/08/19/一个简单的询问/","excerpt":"给你一个长度为 $N$ 的序列 $a_i$，$1\\leq i\\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出 $$\\sum\\limits_{x=0}^\\infty \\text{get}(l_1,r_1,x)\\cdot \\text{get}(l_2,r_2,x)$$ $ \\text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。","text":"给你一个长度为 $N$ 的序列 $a_i$，$1\\leq i\\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出 $$\\sum\\limits_{x=0}^\\infty \\text{get}(l_1,r_1,x)\\cdot \\text{get}(l_2,r_2,x)$$ $ \\text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。 题目链接「SNOI2017」一个简单的询问 输入输出格式输入格式：第一行，一个数字 $N$，表示序列长度。 第二行，$N$ 个数字，表示 $a_1\\sim a_N$。 第三行，一个数字 $Q$，表示询问个数。 第 $4\\sim Q+3$ 行，每行四个数字 $l_1,r_1,l_2,r_2$，表示询问。 输出格式对于每组询问，输出一行一个数字，表示答案。 输入输出样例样例输入1234551 1 1 1 121 2 3 41 1 4 4 样例输出1241 说明对于 $20%$ 的数据，$1\\leq N,Q\\leq 1000$； 对于另外 $30%$ 的数据，$1\\leq a_i\\leq 50$； 对于 $100%$ 的数据，$N,Q\\leq 50000$，$1\\leq a_i\\leq N$，$1\\leq l_1\\leq r_1\\leq N$，$1\\leq l_2\\leq r_2\\leq N$。 注意：答案有可能超过 int 的最大值。实测好像没有？数据水了？ 题解又是面向题解解题的一道题目。看了一眼，这能是莫队？莫队不是用于单区间操作的么？难道用两个莫队？一个查询前面，一个查询后面？可是要怎么排序？怎么让排序过后的区间仍然保持匹配？种种问题，让我不会。第一次看题解，那么长的推到，好了不会，超过能力范围了。偶然看了一个代码，发现不长，去看看推倒过程还是很简单的。 题中要求 $[l_1,r_1] $ ~ $ [l_2,r_2]$ 区间内 $x$ 出现次数的乘积。对于 $[l_1,r_1] $ 区间，我们把 $\\text{get}(l,r,x)$ 转化为 $\\text{get}(1,r,x) - \\text{get}(1,l-1,x)$ (类似与主席树？) 设 $s(i) = \\text{get}(l,i,x)$。 则对于体中要求的式子，我们可以转化为$$\\sum\\limits_{x=0}^\\infty (\\text{get}(1,r_1,x) - \\text{get}(1,l_1-1,x))\\cdot(\\text{get}(1,r_2,x) - \\text{get}(1,l_2-1,x))$$ &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;$\\Downarrow$ $$\\sum\\limits_{x=0}^\\infty (s(r_1)- s(l_1-1))\\cdot(s(r_2) - s(l_2-1)) $$ &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;$\\Downarrow$ $$s(r_1)\\cdot s(r_2) + s(l_1-1)\\cdot s(l_2-1) - s(r_1)\\cdot s(l_2-1) - s(r_2)\\cdot s(l_1-1) $$ 由这个平方和公式 $a\\cdot b=\\dfrac {\\left( a^{2}+b^{2}\\right) -a^{2}-b^{2}}{2}$ &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;$\\Downarrow$ $\\dfrac {\\left( s\\left( r_{1}\\right) +s\\left( r_{2}\\right) \\right) ^{2} + \\left( s\\left( l_{1}-1\\right) +s\\left( l_{2}-1\\right) \\right) ^{2} - \\left( s\\left( r_{2}\\right) +s\\left( l_{1}-1\\right) \\right) ^{2} - \\left( s\\left( r_{1}\\right) +s\\left( l_{2}-1\\right) \\right) ^{2}} {2}$ 仔细观察这个式子，可以得到分子就是区间 $[r1,l2],[l1,r2],[l1,l2],[r1,r2]$ 中 $x$ 出现个数的平方。这样一来，再用莫队去做区间修改时，当减少一个数时就是从 $x^2 \\to (x-1)^2$，也就是每次减少了 $2\\cdot x-1$ 增加就是加上 $2\\cdot x+1$这样，这题就解了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;const int MAXN = 1e5 + 5;using namespace std;typedef long long ll;int n, m, block, belong[MAXN], cnt[MAXN];int tot, l1, l2, r1, r2;ll sum;struct Node &#123; int l, r, id, sgin;&#125; data[MAXN &lt;&lt; 2];int a[MAXN], ans[MAXN];int cmp(Node a, Node b) &#123; return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125;void put(int l, int r, int id, int sgin) &#123; data[++tot].l = min(l, r) + 1; //画完柿子后会发现变成了s(r大)-s(l小),也就是求l+1--r的x平方和 data[tot].r = max(l, r); data[tot].id = id; data[tot].sgin = sgin;&#125;void add(int x) &#123; sum += cnt[x] * 2 + 1; cnt[x]++;&#125;void del(int x) &#123; sum -= cnt[x] * 2 - 1; cnt[x]--;&#125;void Build() &#123; block = sqrt(n); for (int i = 1; i &lt;= n; i++) belong[i] = (i - 1) / block + 1;&#125;int main() &#123; scanf(\"%d\", &amp;n); Build(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); scanf(\"%d\", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d %d %d %d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); l1--; l2--; put(r1, r2, i, 1); //把区间拆分 put(l1, l2, i, 1); put(l1, r2, i, -1); put(l2, r1, i, -1); &#125; sort(data + 1, data + 1 + tot, cmp); int L = 0, R = 0; for (int i = 1; i &lt;= tot; i++) &#123; int ql = data[i].l, qr = data[i].r; while (L &lt; ql) del(a[L++]); while (R &lt; qr) add(a[++R]); while (L &gt; ql) add(a[--L]); while (R &gt; qr) del(a[R--]); ans[data[i].id] += sum * data[i].sgin; &#125; for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", -ans[i] / 2); //结果为啥时负的我也不知道 return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"「美团 CodeM 初赛 Round A」数列互质","slug":"数列互质","date":"2019-08-13T04:11:30.000Z","updated":"2019-08-13T06:50:20.502Z","comments":true,"path":"2019/08/13/数列互质/","link":"","permalink":"http://yoursite.com/2019/08/13/数列互质/","excerpt":"给出一个长度为 $n$ 的数列 ${ a_1 , a_2 , a_3 , … , a_n }$，以及 $m$ 组询问 $( l_i , r_i , k_i)$，求区间 $[ l_i , r_i ]$ 中有多少数在该区间中的出现次数与 $k_i$ 互质。","text":"给出一个长度为 $n$ 的数列 ${ a_1 , a_2 , a_3 , … , a_n }$，以及 $m$ 组询问 $( l_i , r_i , k_i)$，求区间 $[ l_i , r_i ]$ 中有多少数在该区间中的出现次数与 $k_i$ 互质。 题目链接「美团 CodeM 初赛 Round A」数列互质 输入输出格式输入格式：第一行，两个正整数 $n , m$。 第二行，$n$ 个正整数 $a_i$ 描述这个数列。 接下来 $m$ 行，每行三个正整数 $l_i , r_i , k_i$，描述一次询问。 输出格式输出 $m$ 行，即每次询问的答案。 输入输出样例样例输入123456710 51 1 1 1 1 2 2 2 2 24 7 24 7 34 8 24 8 33 8 3 样例输出1234502110 说明 $1\\le n,m\\le 5\\times 10^4$ $1\\le a_i\\le n$ $1\\le l_i\\le r_i\\le n$ $1\\le k_i\\le n$ 题解先看这是一个区间问题，大概率数据结构。再看一眼数据范围，恩莫队可解，成了。题目中要求统计某个数在 $[L,R]$ 有多少个数出现的次数与 $K$ 互质。我们开两个数组，一个记录区间内每个数出现的次数，另一个数组记录这个数出现的次数的次数。绕口令？ 比如 样例的 $[4,7]$ 第一个数组 $cnt$就记录了区间内 $cnt[1] = 2，cnt[2] = 2$ $1,2$ 分别各出现两次。另一个数组 $num$ 用来记录 $num[cnt[1]] = 2$ ,代表这个区间内 $2$ 这个数出现了两次。这样在用莫队，统计的时候就方便了。剩下的看注释吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 5e5 + 7;const int INF = 0x3f3f3f3f;int block, num[MAXN], cnt[MAXN], belong[MAXN];int n, m, a[MAXN], x, y, ret, ans[MAXN];bool vis[MAXN];vector&lt;int&gt; V;struct Node &#123; int l, r, k, id;&#125; data[MAXN];bool cmp(Node a, Node b) &#123; return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125;int read() &#123; int x = 0, flag = 1; char ch = 0; while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') flag = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - 48; ch = getchar(); &#125; return x * flag;&#125;void write(int x) &#123; if (x &lt; 0) x = -x, putchar('-'); if (x &gt; 9) write(x / 10); putchar(x % 10 + 48);&#125;int gcd(int x, int y) &#123; return (y) ? gcd(y, x % y) : x; &#125;void Build() &#123; block = sqrt(n); for (int i = 1; i &lt;= n; i++) belong[i] = (i - 1) / block + 1;&#125;void solve(int x, int op) &#123; --num[cnt[x]]; //先把这个数的贡献减去，再把后来改变的加上 cnt[x] += op; ++num[cnt[x]]; int t = cnt[x]; if (t &amp;&amp; !vis[t]) //如果这个数的出现次数不是0，并且这个出现的次数以前没在这个区间出现过，把他放到数组里，留到后面遍历 vis[t] = 1, V.push_back(t);&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); &#125; Build(); for (int i = 1; i &lt;= m; i++) &#123; data[i].l = read(); data[i].r = read(); data[i].k = read(); data[i].id = i; &#125; sort(data + 1, data + 1 + m, cmp); int L = 1, R = 0; for (int i = 1; i &lt;= m; i++) &#123; int ql = data[i].l, qr = data[i].r, qk = data[i].k; while (ql &lt; L) solve(a[--L], 1); // 这里的顺序要特别注意不然会RE，具体自己手动领悟 while (qr &gt; R) solve(a[++R], 1); while (ql &gt; L) solve(a[L++], -1); while (qr &lt; R) solve(a[R--], -1); int t = 0, sz = V.size(); //V里面存的是出现的次数 for (int j = 0; j &lt; sz; j++) &#123; if (num[V[j]]) &#123; if (gcd(V[j], qk) == 1) ans[data[i].id] += num[V[j]]; V[t++] = V[j]; &#125; else &#123; vis[V[j]] = 0; //当前区间内这个数出现的次数的次数为0，把他的标记去掉 &#125; &#125; for (int j = sz - t; j &gt;= 1; j--) V.pop_back(); //把那些出现次数的次数为0的数删去 &#125; for (int i = 1; i &lt;= m; i++) &#123; write(ans[i]), puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"2019牛客暑期多校训练营   (第七场) - C - Governing sand","slug":"newke7-C","date":"2019-08-12T08:04:00.000Z","updated":"2019-08-12T08:47:38.846Z","comments":true,"path":"2019/08/12/newke7-C/","link":"","permalink":"http://yoursite.com/2019/08/12/newke7-C/","excerpt":"The Wow village is often hit by wind and sand,the sandstorm seriously hindered the economic development of the Wow village.There is a forest in front of the Wowo village, this forest can prevent the invasion of wind and sand. But there is a rule that the number of tallest trees in the forest should be more than half of all trees, so that it can prevent the invasion of wind and sand. Cutting down a tree need to cost a certain amount of money. Different kinds of trees cost different amounts of money. Wow village is also poor.There are n kinds of trees. The number of i-th kind of trees is $P_i$ , the height of i-th kind of trees is $H_i$，the cost of cutting down one i-th kind of trees is $C_i$.","text":"The Wow village is often hit by wind and sand,the sandstorm seriously hindered the economic development of the Wow village.There is a forest in front of the Wowo village, this forest can prevent the invasion of wind and sand. But there is a rule that the number of tallest trees in the forest should be more than half of all trees, so that it can prevent the invasion of wind and sand. Cutting down a tree need to cost a certain amount of money. Different kinds of trees cost different amounts of money. Wow village is also poor.There are n kinds of trees. The number of i-th kind of trees is $P_i$ , the height of i-th kind of trees is $H_i$，the cost of cutting down one i-th kind of trees is $C_i$. 题意$N$ 种树，每种树有一个高度，砍掉需要的花费，以及数量。现在我们要把最高的树的数目严格大于所有树数目的一半。问所需要的最小花费是多少。 题目链接Governing sand 输入输出格式输入格式多组输入输出且不超过30组对于每组测试样例第一行一个 $N$ 表示有 $N$ 种树 $ 1 \\leq N \\leq 10^5 $。剩下 $N$ 行，每行有三个数 $H_i$ ($ 1 \\leq H_i \\leq 10^9 $)， $C_i$ ($ 1 \\leq C_i \\leq 200 $)，$P_i$ ($ 1 \\leq P_i \\leq 10^9 $)，分别代表树的高度，砍掉这颗树需要的花费，这颗树的数量。 输出格式对于每个测试用例，应输出最低成本。 输入输出样例输入样例12345625 1 11 10 125 1 23 2 3 输出样例1212 说明题目中要求数目的高度必须严格大于 题解场上没思路，场下看题解，这题我会啦，这题就是个B级题 说正题，题中要求最高的树的数量要大于所有树个数的一半。暴力？贪心？DP？主席树？场上都想过，都没有思路。这题有两种暴力方法一种 $O(n^2)$，另一种 $O(n*c)$，后者可过，所以这题成为了这一场的签到题，我怎么就没想到敲！但是既然是场下补题了就不写暴力了，太LOW。这题 $C$ 的数据范围完全可以出到 $10^9$。就按 $10^9$的数据范围写吧。 首先我们对这写树按照高度排序，从小到大去遍历这些树，对于第 $i$ 颗树，假设它就是这篇森林里面最高的树，那么对于当前这颗树 比它高的树全部砍去 比它矮的树砍去代价最少的使它满足题目要求 处理了这两个点这题就AC了。对于第一个点，记录一下后缀和，$v[i]$ 表示以 $i$ 颗树为最高树时砍到后面所有树所需要的花费。很容易想到，这肯定要预处理，这样第一个点就解决了。 对于第二个点，要找在比第 $i$ 颗树矮的树里面找到足够的数目保证题意并且花费最小。这里我们就可以开一个主席树，后者权值线段树。我选择了后者，但是看某篇题解好像说主席树简单好想一点？可我不会主席树难搞。就按权值线段树来写。对于权值线段树，我们维护两个值 $[1-i]$ 内树的数量和砍到这些树的代价和。向后进行枚举，到第i种树时，先把答案加上 $v[i+1]$ 表示如果第 $i$ 种树最高，那么它后面所有种类的树都要砍掉，然后去查询第$i$种树最高的情况下，前面最少需要砍掉树的代价是多少。需要注意的是多种树的高度相同的情况。总时间复杂度 $O(n* \\log c)$，对与 $C$ 是 $10^9$的数据范围，离散化后一样写。 总结一些自闭历程 全程要开 $long long$ ans的数据范围一开始一直没给够给了 $INF$ 一直没找到BUG 对比了半天题解发现开小了 还有就是代码比较长，容易多大或者少打一些符号，还是代码打的少。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5e5+7;typedef long long ll;const long long INF = 0x7fffffff;ll v[MAXN],n;struct node &#123; ll h,c,p; bool operator &lt; (const node a)const &#123; return a.h &gt; h; &#125;&#125; data[MAXN];struct Node &#123; ll l,r,val,num;&#125; T[MAXN &lt;&lt; 2];void PushUp(int rt) &#123; T[rt].num = T[rt &lt;&lt; 1].num + T[rt &lt;&lt; 1|1].num; T[rt].val = T[rt &lt;&lt; 1].val + T[rt &lt;&lt; 1|1].val;&#125;void Build(ll l,ll r,ll rt) &#123; T[rt].l = l,T[rt].r = r; T[rt].val = T[rt].num = 0; if(l == r) return ; ll mid = (l + r) &gt;&gt; 1; Build(l,mid,rt &lt;&lt; 1); Build(mid+1,r,rt &lt;&lt; 1|1); PushUp(rt);&#125;void Update(ll val,ll num,ll rt) &#123; if(T[rt].l == T[rt].r) &#123; T[rt].num += num; T[rt].val += (ll)num * (ll)val; return ; &#125; ll mid = T[rt].l + T[rt].r &gt;&gt; 1; if(mid &gt;= val) Update(val,num,rt &lt;&lt; 1); else Update(val,num,rt &lt;&lt; 1|1); PushUp(rt);&#125;ll Query(ll rt,ll num) &#123; if(num &gt;= T[rt].num) return T[rt].val; if(T[rt].l == T[rt].r) return min(num*T[rt].l,T[rt].val); if(T[rt &lt;&lt; 1].num &gt;= num) return Query(rt &lt;&lt; 1,num); else return T[rt &lt;&lt; 1].val + Query(rt &lt;&lt; 1|1,num - T[rt &lt;&lt; 1].num);&#125;void init() &#123; memset(v,0,sizeof(v));&#125;int main() &#123; ios::sync_with_stdio(false); while(cin &gt;&gt; n) &#123; init(); ll l = INF,r = -1; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; data[i].h &gt;&gt; data[i].c &gt;&gt; data[i].p; l = min((ll)l,data[i].c); r = max((ll)r,data[i].c); &#125; sort(data+1,data+1+n); for(int i = n; i &gt;= 1; i--) v[i] = v[i+1] + (data[i].c*data[i].p); Build(l,r,1); ll ans = 1e18,sum = 0; for(int i = 1; i &lt;= n; i++) &#123; int k; ll now = 0; for(k = 0; i+k &lt;= n; k++) &#123; if(data[i].h != data[i+k].h) break; now += data[i+k].p; &#125; k--; ll mid = v[i+k+1]; if(sum &gt;= now) &#123; mid += Query(1,sum - now + 1); &#125; ans = min(ans,mid); sum += now; for(int j = i; j &lt;= i+k; j++) &#123; Update(data[j].c,data[j].p,1); &#125; i += k; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"权值线段树","slug":"权值线段树","permalink":"http://yoursite.com/tags/权值线段树/"}]},{"title":"Chika and Friendly Pairs (莫队+ 树状数组 + 离散化 + 预处理)","slug":"HDU6534","date":"2019-08-10T09:33:56.000Z","updated":"2019-08-19T10:06:46.193Z","comments":true,"path":"2019/08/10/HDU6534/","link":"","permalink":"http://yoursite.com/2019/08/10/HDU6534/","excerpt":"一个区间中如果存在这样的一对数字 $（A,B）$ 并且 $abs（A-B）$ 不大于 $K$ ，我们就称这一对数字为奇妙的数字对。现在给出你长为n的序列，求奇妙数字对 $（i，j）$ 在 $[L,R]$ 中的个数。","text":"一个区间中如果存在这样的一对数字 $（A,B）$ 并且 $abs（A-B）$ 不大于 $K$ ，我们就称这一对数字为奇妙的数字对。现在给出你长为n的序列，求奇妙数字对 $（i，j）$ 在 $[L,R]$ 中的个数。 题目链接Hdu-6534-Chika and Friendly Pairs 输入输出格式输入格式：第一行输入三个数字 $N,M,K$; 第二行有 $N$ 个数字，代表序列。 第三行有 $M$ 次询问 $L,R$ 输出格式输出$M$行。每行一个数字，代表询问区间的奇妙数字对的个数。 输入输出样例输入样例12345677 5 3 2 5 7 5 1 5 6 6 6 1 3 4 6 2 4 3 4 输出样例1234502131 说明对于 $ 100% $ 的数据，$ 1 \\leq n \\leq 27000, 1 \\leq m \\leq 27000， 1 \\leq k \\leq 10 ^ 9 ， n个数字都不超过10^9$。 题解首先，看到题目中的数据范围 $27000$ 为什么不是 $1e5$ 为什么不是 $3e4$ $?$ 想到可能可以用分块或者莫队去暴力。 可是想了很久也没想到用莫队或者分块去维护什么东西 我好菜 。慢慢去想。 首先很容易想到，对于这样的数对，我们可以枚举这个序列直接 $n^2$ 暴力去求解，此时时间复杂度为$O(m * n^2)$ 显而易见是不可取的 想想如何去降低一下时间复杂度$?$ 对于题目中的式子 $|A - B| \\leq K $ 把他化简开可以的得到这样的一个式子$ -K \\leq A - B \\leq K $ 这样的话，对于某个区间内的所有数，能跟当前枚举出来的数 $x$ 组成满足题意的数对的，一定在 $[x-k,x+k]$ 这个区间里，我们只需要统计这个区间有多少个数就行了。这样每一侧的操作是 $O(m* L* L)$ (L代表区间长度),当然还是会T，还要优化。但是现在问的是对于某个给定的区间内的所有数能够组成的合法数对个数，我们就不能对区间每个数都像上面这样子暴力去统计了。那要怎么办呢？。 首先对于我们的 $M$ 次查询，如果每次都重新对一个区间进行查询一定会进行很多重复的查询，如果能利用这部分重复的信息就可以把时间复杂度再下一个级。使用莫队算法能够使得我们有效利用重叠区间所统计的答案，使时间复杂度变为 $O(m* \\sqrt{L} * L)$。马上就对了！ 此时唯一还能优化的地方就是，再 $[L,R]$ 区间内符合的数的个数。对于每次查询和修改，不必要区间的每个数都重新跑一边，而利用不必过多的修改统计的树状数组，将 $O(L^2)$ 的查询变成 $O(L* \\log L)$ 这个题就优化完了 总时间复杂度为 $O(m * \\sqrt{n} * \\log n)$ 对于区间 $[x-k,x+k]$ 我们需要先知道每个 $a_i$ 所对应的左右区间分别到哪里，所以预处理这个序列对 $x-k,x+k$ ，数据太大需要离散化，剩下的代码注释把。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5+7;int block,num,belong[MAXN],tree[MAXN],l[MAXN],r[MAXN];int n,m,k,u,v,ans[MAXN];int a[MAXN],b[MAXN],c[MAXN],tot;int get_num()&#123; int num = 0; char c; bool flag = false; while((c = getchar()) == ' ' || c == '\\r' || c == '\\n'); if(c == '-') flag = true; else num = c - '0'; while(isdigit(c = getchar())) num = (num&lt;&lt;3) + (num&lt;&lt;1) + c - '0'; return (flag ? -1 : 1) * num;&#125;struct Node &#123; int l,r,id; bool operator &lt;(const Node &amp;S)const &#123; return (belong[l] ^ belong[S.l]) ? belong[l] &lt; belong[S.l] : ((belong[l] &amp; 1) ? r &lt; S.r : r &gt; S.r); //莫队奇偶玄学排序 &#125;&#125; data[MAXN];void Build() &#123; block = sqrt(n); num = n/block; if(n % block) num++; for(int i = 1; i &lt;= n; i++) belong[i] = (i-1)/block + 1;&#125;int lowbit(int x) &#123; return x &amp; (-x);&#125;void Update(int x,int d) &#123; for(int i = x; i &lt;= tot; i += lowbit(i)) &#123; tree[i] += d; &#125;&#125;int Sum(int x) &#123; int ret = 0; for(int i = x;i &gt; 0;i -= lowbit(i)) ret += tree[i]; return ret;&#125;int main() &#123; n = get_num(); m = get_num(); k = get_num(); Build(); for(int i = 1; i &lt;= n; i++) a[i] = get_num(),b[i] = a[i]; sort(b+1,b+1+n); //对数据进行离散化 c[1] = b[1]; tot = 1; for(int i = 2; i &lt;= n; i++) &#123; if(b[i] != b[i-1]) c[++tot] = b[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; //预处理每个值所处的区间边界 l[i] = lower_bound(c+1,c+1+tot,a[i] - k) - c; r[i] = upper_bound(c+1,c+1+tot,a[i] + k)- c - 1; a[i] = lower_bound(c+1,c+tot+1,a[i]) - c; &#125; for(int i = 1; i &lt;= m; i++) &#123; data[i].l = get_num(); data[i].r = get_num(); data[i].id = i; &#125; sort(data+1,data+1+m); int L = 1,R = 0,temp = 0; for(int i = 1; i &lt;= m; i++) &#123; int ql = data[i].l,qr = data[i].r; while(ql &lt; L) &#123; L--; temp += Sum(r[L]) - Sum(l[L] - 1); Update(a[L],1); &#125; while(ql &gt; L) &#123; Update(a[L],-1); temp -= Sum(r[L]) - Sum(l[L] - 1); L++; &#125; while(qr &lt; R) &#123; Update(a[R],-1); temp -= Sum(r[R]) - Sum(l[R] - 1); R--; &#125; while(qr &gt; R) &#123; R++; temp += Sum(r[R]) - Sum(l[R] - 1); Update(a[R],1); &#125; ans[data[i].id] = temp; &#125; for(int i = 1; i &lt;= m; i++) &#123; printf(\"%d\\n\",ans[i]); &#125; //printf(\"Time cost : %lf s\\n\",(double)clock()/CLOCKS_PER_SEC); return 0;&#125; 自闭历程题目来源是2019CCPC湘潭邀请赛的一岛银牌题，但在这道题上有了一些变动，目前为止这是我写过最难的一道题，从这个题在我眼前出现，到搜题解把这个题AC一共用了3天的时间，让我持续自闭。后期还要把这个题拿出来在学一遍。从开始的暴力，到线段树维护区间差值，发现线段树的区间不能完全覆盖，到看到Luogu的P1102想到把式子拆分，用分块维护两个式子，发现时间复杂度还是过高，再到用莫队去利用多余数据，发现根本不知道怎么利用这个重复的查询，用主席树去求每个区间内的有多少个数超时的操作，等等等等……真的是把我目前已知的所有东西都用上了，一度陷入了自闭的状态，去网上搜题解也都搜不到，直到问了一个湘潭大学的金牌选手从他那里得知这到题目的出处，看了题解才过掉。一路自闭，一路慢慢搞懂，好难，我好菜。 题意延申一个区间中如果存在这样的一对数字 $（A,B）$ 并且 $abs（A-B）$ 不小于 $K$ ，我们就称这一对数字为奇妙的数字对。现在给出你长为n的序列，求奇妙数字对 $（i，j）$ 在 $[L,R]$ 中的个数。 源自集训队WHY大佬出的题目，在原题的基础上改一下每个数字的上下界，稍作修改即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 3e4 + 9;struct Node &#123; int l, r, id;&#125; q[MAXN];int belong[MAXN], ans[MAXN];int tree[MAXN * 4], c[MAXN * 4];int r_r[MAXN], l_l[MAXN];int b[MAXN], a[MAXN];int res = 0;bool cmp(Node a, Node b) &#123; return ((belong[a.l] == belong[b.l]) ? (a.r &lt; b.r) : (a.l &lt; b.l)); &#125;int lowbit(int x) &#123; return x &amp; (-x); &#125;void add(int x, int v) &#123; while (x &lt;= MAXN * 3) &#123; tree[x] += v; x += lowbit(x); &#125;&#125;int get(int x) &#123; int ans = 0; while (x) &#123; ans += tree[x]; x -= lowbit(x); &#125; return ans;&#125;int main() &#123; int n, m, k; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); int u = sqrt(n), cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); a[i] = x; c[++cnt] = x; c[++cnt] = x - k; c[++cnt] = x + k - 1; belong[i] = i / u + 1; &#125; sort(c + 1, c + 1 + cnt); int num = unique(c + 1, c + 1 + cnt) - c - 1; for (int i = 1; i &lt;= n; i++) &#123; r_r[i] = lower_bound(c + 1, c + 1 + num, a[i] + k - 1) - c; l_l[i] = lower_bound(c + 1, c + 1 + num, a[i] - k) - c; b[i] = lower_bound(c + 1, c + 1 + num, a[i]) - c; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d %d\", &amp;q[i].l, &amp;q[i].r); q[i].id = i; &#125; sort(q + 1, q + m + 1, cmp); int l = 1, r = 0, res = 0, sum = 0; for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) &#123; r++; res += sum - get(r_r[r]) + get(l_l[r]); add(b[r], 1); sum++; &#125; while (r &gt; q[i].r) &#123; add(b[r], -1); sum--; res -= sum - get(r_r[r]) + get(l_l[r]); r--; &#125; while (l &lt; q[i].l) &#123; add(b[l], -1); sum--; res -= sum - get(r_r[l]) + get(l_l[l]); l++; &#125; while (l &gt; q[i].l) &#123; l--; res += sum - get(r_r[l]) + get(l_l[l]); add(b[l], 1); sum++; &#125; ans[q[i].id] = res; &#125; for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"Lougu-3865-【模板】ST表（倍增写法）","slug":"Lougu3865（ST表+倍增思想）","date":"2019-07-15T02:54:17.000Z","updated":"2019-08-06T05:09:53.723Z","comments":true,"path":"2019/07/15/Lougu3865（ST表+倍增思想）/","link":"","permalink":"http://yoursite.com/2019/07/15/Lougu3865（ST表+倍增思想）/","excerpt":"给定一个长度为 N N 的数列，和 M M 次询问，求出每一次询问的区间内数字的最大值。","text":"给定一个长度为 N N 的数列，和 M M 次询问，求出每一次询问的区间内数字的最大值。 题目链接Lougu-3865-【模板】ST表 输入输出格式输入格式：第一行包含两个整数 N , M 分别表示数列的长度和询问的个数。 第二行包含 N N 个整数（记为 ai a i)，依次表示数列的第 i 项。 接下来 M行，每行包含两个整数 li, ri，表示查询的区间为 [ li, ri]输出格式：输出包含 M M行，每行一个整数，依次表示每一次询问的结果。输入输出样例输入样例1： 8 89 3 1 7 5 6 0 81 61 52 72 61 84 83 71 8 输出样例1： 99779879 题解显然这是一道ST表的模板题。~ 但是重点在于倍增的思想。相比于二分，我们每次对于一个序列进行÷2的折半查找，而倍增则是每次对于序列×2的查 找。对于倍增一个很好的运用就是RMQ。(在？为什么不是LCA)RMQ就是维护静态区间极值问题，预处理的时间复杂度为O(n*logn)，查询为O(1),对于 这道模板题，就必须是O(1)的输出。什么是倍增？倍增用到了2进制的思想。我们把数组分割为2的次方倍。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Luogu-1338-末日传说","slug":"Luogu1338","date":"2019-07-14T09:41:40.000Z","updated":"2019-08-10T09:49:45.141Z","comments":true,"path":"2019/07/14/Luogu1338/","link":"","permalink":"http://yoursite.com/2019/07/14/Luogu1338/","excerpt":"只要是参加jsoi活动的同学一定都听说过Hanoi塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。 在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从1开始的连续整数，1表示最小而N表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。 我们用1-N来表示日历的元素，第一天日历就是 1, 2, 3, … N 第二天，日历自动变为 1, 2, 3, … N, N-1 ……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。 日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃……他还预言到，假如某一个日期的逆序达到一个值M的时候，世界末日就要降临。 什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到M后，末日就要降临，人们都期待一个贤者，能够预见那一天，到底将在什么时候到来？","text":"只要是参加jsoi活动的同学一定都听说过Hanoi塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。 在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从1开始的连续整数，1表示最小而N表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。 我们用1-N来表示日历的元素，第一天日历就是 1, 2, 3, … N 第二天，日历自动变为 1, 2, 3, … N, N-1 ……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。 日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃……他还预言到，假如某一个日期的逆序达到一个值M的时候，世界末日就要降临。 什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到M后，末日就要降临，人们都期待一个贤者，能够预见那一天，到底将在什么时候到来？ 题目链接Luogu-1338-末日传说 输入输出格式输入格式只包含一行两个正整数，分别为N和M。 输出格式输出一行，为世界末日的日期，每个数字之间用一个空格隔开。 输入输出样例输入样例1：5 4输出样例1：1 3 5 4 2说明对于10%的数据有N &lt;= 10。 对于40%的数据有N &lt;= 1000。 对于100%的数据有 N &lt;= 50000。 所有数据均有解。 题解题目意思看了半天没看懂搜了题解看到的题意。意思是给你一个N，让你在1-N的序列中找到一个序列使得这个序列的逆序对的个数满足M,并且该序列的字典序最小。 对于一个序列，它的最大逆序对的个数给n*(n-1)/2，即该序列严格降序。所以当我们按位来考虑这个序列的逆序数时，我们去判断这一位对该序列逆序对的贡献是否比M大。例如N = 5，M = 4.我们在考虑1的时候可以计算得出，剩下的4位数可以产生的最大逆序对的个数是比M大的，所以这个1可有可无，我们就可以把他放到序列的最前端。而到了2时我们发现，去掉了这个2是无法满足逆序对大于M的要求，此时按照贪心我们把2放到最后，这样可以使2这个数产生的逆序对最多，也就使M减小的最多，进而影响后面我们可以找到跟多的无关元素。这样就好写了。对于每个数都有两种方式 去掉当前数，剩下的数仍可构成比M多个逆序对把当前数放到后方，让M-（当前数提供的逆序对的个数）这样直接O(n)的时间复杂度就过去了(要开long long)。 代码1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;typedef long long ll;const int MAXN = 1e5+7;const int INF = 0x7fffffff;using namespace std;ll a[MAXN]; int main() &#123; ll n,m; cin &gt;&gt; n &gt;&gt; m; ll ans[MAXN],l = 1,r = n; for(ll i = 1; i &lt;= n; i++) &#123; ll t = (n-i)*(n-i-1)/2; if(t &gt;= m) &#123; ans[l] = i; l++; &#125; else &#123; ans[r] = i; r--; m -= (r - l + 1); &#125; &#125; for(ll i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; \" \"; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://yoursite.com/tags/思维/"}]},{"title":"Luogu-1725-琪露诺","slug":"Luogu1725","date":"2019-06-10T09:33:56.000Z","updated":"2019-08-10T09:47:49.337Z","comments":true,"path":"2019/06/10/Luogu1725/","link":"","permalink":"http://yoursite.com/2019/06/10/Luogu1725/","excerpt":"在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。 某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。 小河可以看作一列格子依次编号为0到N，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子i时，她只移动到区间[i+l,i+r]中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。 每一个格子都有一个冰冻指数A[i]，编号为0的格子冰冻指数为0。当琪露诺停留在那一格时就可以得到那一格的冰冻指数A[i]。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。 但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。 开始时，琪露诺在编号0的格子上，只要她下一步的位置编号大于N就算到达对岸。","text":"在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。 某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。 小河可以看作一列格子依次编号为0到N，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子i时，她只移动到区间[i+l,i+r]中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。 每一个格子都有一个冰冻指数A[i]，编号为0的格子冰冻指数为0。当琪露诺停留在那一格时就可以得到那一格的冰冻指数A[i]。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。 但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。 开始时，琪露诺在编号0的格子上，只要她下一步的位置编号大于N就算到达对岸。 题目链接Luogu-1725-琪露诺 输入输出格式输入格式：第1行：3个正整数N, L, R 第2行：N+1个整数，第i个数表示编号为i-1的格子的冰冻指数A[i-1] 输出格式：一个整数，表示最大冰冻指数。保证不超过2^31-1 输入输出样例输入样例1：5 2 3 0 12 3 11 7 -2输出样例1：11说明对于60%的数据：N &lt;= 10,000 对于100%的数据：N &lt;= 200,000 对于所有数据 -1,000 &lt;= A[i] &lt;= 1,000且1 &lt;= L &lt;= R &lt;= N 题解看了题后不难想到这个题是个dp，而状态转移方程为dp[i] = max(dp[k]) (k &gt;=i+l &amp;&amp; k &lt;= i+r) + a[i]。如果暴力去dp会多了一层（l,r)的循环，可能会超时，所以对区间(l,r)进行优化，用单调队列进行优化。维护区间【l,r】的最大值即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;typedef long long ll;const int INF = 0x3f3f3f3f;const int MAXN = 2e6+7;using namespace std;int a[MAXN];int dp[MAXN],q[MAXN]; //单调队列存的是下标 int main() &#123; int n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; for(int i = 0;i &lt;= n;i++) cin &gt;&gt; a[i]; int head = 1,tail = 0,p = 0; int ans = -1; memset(dp,-1,sizeof(dp)); //对于所有的点初始值都为最小 dp[0] = 0;//在0点为0 for(int i = l;i &lt;= n;i++)&#123; //从0开始，第一个能跳的点就是l,往后依次判断 while(head &lt;= tail &amp;&amp; dp[q[tail]] &lt; dp[p]) tail--; //如果当前队列内的值小于最新的值，直接把他删去即可 tail++; q[tail] = p;//记录是第几个入队的 if(q[head] + r &lt; i) //如果此时队头的下标加上r比i小，要把队头删去 head++; dp[i] = dp[q[head]] + a[i]; p++; &#125; for(int i = n-r+1;i &lt;= n;i++) //对于能跳到对岸的点找一个最大值即可 ans = max(ans,dp[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/categories/ACM/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://yoursite.com/tags/dp/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"to Splay","slug":"toSplay","date":"2018-09-12T13:00:00.000Z","updated":"2019-07-14T14:23:20.949Z","comments":true,"path":"2018/09/12/toSplay/","link":"","permalink":"http://yoursite.com/2018/09/12/toSplay/","excerpt":"故事伊始曾经想把代码精简，到最后AC才发现，这代码字里行间，全部都是她。 你看这颗可爱的线段树，它可以这样转，这样转，再这样转…….. 《驻马店不相信眼泪》zzzhy讲话实录","text":"故事伊始曾经想把代码精简，到最后AC才发现，这代码字里行间，全部都是她。 你看这颗可爱的线段树，它可以这样转，这样转，再这样转…….. 《驻马店不相信眼泪》zzzhy讲话实录 上面这两句经典语录是为了致敬我的卓哥，牺牲自己的恋爱时间来帮我搭博客（虽然他没有对象）。 博客就这样搭好了，这几天先拉些写过的水题充充场面。第一次搭建博客，好多地方都还不完善，欢迎各位指点，这个暑假会慢慢补充改进。 未完待续。。。","categories":[],"tags":[{"name":"人民艺术家 zzzhy","slug":"人民艺术家-zzzhy","permalink":"http://yoursite.com/tags/人民艺术家-zzzhy/"}]}]}